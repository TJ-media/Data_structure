# -*- coding: utf-8 -*-
"""5_이진트리조상과깊이.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aaB7Cd1MbTGlcaUa25BXOssxJCfiIi1_
"""

def preorder(v):
	root = find_root()
	pre = [0]*(n+1)

	if root == 0:
		return 0

	def time(node, t):
		pre[node] = t
		if left[node] != 0:
			t = time(left[node], t + 1)
		if right[node] != 0:
			t = time(right[node], t + 1)
		return t

	time(root, 1)
	return pre[v]


def postorder(v):
	root = find_root()
	post = [0]*(n+1)

	if root == 0:
		return 0

	def time(node, t):
		if left[node] != 0:
			t = time(left[node], t)
		if right[node] != 0:
			t = time(right[node], t)
		post[node] = t
		return t + 1

	time(root, 1)
	return post[v]


def depth(v):
	depth_ = 0
	while parent[v] != 0:
		v = parent[v]
		depth_ += 1
	return depth_


def is_ancestor(u, v):
	while parent[v] != 0:
		if parent[v] == u:
			return True
		else:
			v = parent[v]
	return False


def lca(u, v):
	if is_ancestor(u, v):
		return u
	elif is_ancestor(v, u):
		return v
	else:
		sub = depth(u) - depth(v)
		if sub > 0:
			for i in range(sub):
				u = parent[u]
		else:
			for j in range(-sub):
				v = parent[v]

		for k in range(depth(u)):
			if parent[u] == parent[v]:
				return parent[u]
				break
			else:
				u = parent[u]
				v = parent[v]
		return None

n = int(input())
parent, left, right = [0]*(n+1), [0]*(n+1), [0]*(n+1)
for i in range(n):
	node = input().split()
	key = int(node[0])
	left_key = int(node[1])
	right_key = int(node[2])

	parent[left_key] = key
	left[key] = left_key
	parent[right_key] = key
	right[key] = right_key

def find_root():
	for i in range(1, len(parent)):
		if parent[i] == 0:
			return i
	return 0

while True:
	cmd = input().split()
	if cmd[0] == 'exit':
		break
	elif cmd[0] == 'preorder':
		res = preorder(int(cmd[1]))
		print(f"  > preorder({int(cmd[1])}) = {res}")
	elif cmd[0] == 'postorder':
		res = postorder(int(cmd[1]))
		print(f"  > postorder({int(cmd[1])}) = {res}")
	elif cmd[0] == 'depth':
		res = depth(int(cmd[1]))
		print(f"  > depth({int(cmd[1])}) = {res}")
	elif cmd[0] == 'is_ancestor':
		res = is_ancestor(int(cmd[1]), int(cmd[2]))
		print(f"  > {int(cmd[1])} is {'an' if res else 'not an'} ancestor of {int(cmd[2])}")
	elif cmd[0] == 'lca':
		res = lca(int(cmd[1]), int(cmd[2]))
		print(f"  > lca({int(cmd[1])}, {int(cmd[2])}) = {res}")
	else:
		print("illegal command")